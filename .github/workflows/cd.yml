name: ğŸš€ SÃ¼rekli DaÄŸÄ±tÄ±m (CD)

# Bu workflow ne zaman Ã§alÄ±ÅŸacak?
on:
  # Main branch'e baÅŸarÄ±lÄ± merge sonrasÄ±
  push:
    branches: [ main ]
  
  # CI workflow'u baÅŸarÄ±lÄ± olduktan sonra
  workflow_run:
    workflows: ["ğŸ§ª SÃ¼rekli Entegrasyon (CI)"]
    branches: [ main ]
    types: [ completed ]
  
  # Manuel deployment
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      version:
        description: 'Version Tag'
        required: false
        default: 'latest'

# Environment variables
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: cicd-demo
  PYTHON_VERSION: '3.11'

jobs:
  # 0ï¸âƒ£ Ã–n Kontroller
  pre-deployment-checks:
    name: ğŸ” Deployment Kontrolleri
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || github.event_name == 'push'
    
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      deployment_env: ${{ steps.check.outputs.deployment_env }}
      version_tag: ${{ steps.check.outputs.version_tag }}
    
    steps:
    - name: ğŸ“¥ Kodu Ä°ndir
      uses: actions/checkout@v4
    
    - name: ğŸ” Deployment KoÅŸullarÄ±nÄ± Kontrol Et
      id: check
      run: |
        echo "ğŸ” Deployment kontrolleri yapÄ±lÄ±yor..."
        
        # Manuel deployment ise
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "deployment_env=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          echo "version_tag=${{ inputs.version || 'latest' }}" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          echo "âœ… Manuel deployment onaylandÄ±"
        else
          echo "deployment_env=staging" >> $GITHUB_OUTPUT
          echo "version_tag=latest" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          echo "âœ… Otomatik deployment onaylandÄ±"
        fi

  # 1ï¸âƒ£ Docker Image Build ve Push
  build-and-push:
    name: ğŸ—ï¸ Build & Push
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true'
    
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: ğŸ“¥ Kodu Ä°ndir
      uses: actions/checkout@v4
    
    - name: ğŸ”§ Docker Buildx Kur
      uses: docker/setup-buildx-action@v3
    
    - name: ğŸ”‘ Container Registry'ye Login
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: ğŸ·ï¸ Metadata HazÄ±rla
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix=sha-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ needs.pre-deployment-checks.outputs.version_tag }}
    
    - name: ğŸ—ï¸ Docker Image Build ve Push
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: ğŸ“ Build Bilgileri
      run: |
        echo "âœ… Docker image baÅŸarÄ±yla build edildi!"
        echo "ğŸ·ï¸ Tags: ${{ steps.meta.outputs.tags }}"
        echo "ğŸ” Digest: ${{ steps.build.outputs.digest }}"

  # 2ï¸âƒ£ Staging Deployment
  deploy-staging:
    name: ğŸš€ Staging Deploy
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-push]
    if: needs.pre-deployment-checks.outputs.deployment_env == 'staging' || needs.pre-deployment-checks.outputs.deployment_env == 'production'
    
    environment:
      name: staging
      url: https://staging.example.com
    
    steps:
    - name: ğŸ“¥ Kodu Ä°ndir
      uses: actions/checkout@v4
    
    - name: ğŸš€ Staging'e Deploy
      run: |
        echo "ğŸš€ Staging ortamÄ±na deployment baÅŸlÄ±yor..."
        echo "ğŸ·ï¸ Image: ${{ needs.build-and-push.outputs.image_tag }}"
        
        # GerÃ§ek deployment komutlarÄ± burada olacak
        # Ã–rnek: kubectl, docker-compose, terraform, vs.
        
        # SimÃ¼le edilen deployment
        echo "ğŸ“¦ Container'Ä± Ã§alÄ±ÅŸtÄ±rÄ±yor..."
        docker run -d --name staging-app \
          -p 5000:5000 \
          -e ENVIRONMENT=staging \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest || true
        
        sleep 10
        echo "âœ… Staging deployment tamamlandÄ±!"
    
    - name: ğŸ” Staging Health Check
      run: |
        echo "ğŸ” Staging health check yapÄ±lÄ±yor..."
        
        # Health check endpoint'ini kontrol et
        curl -f http://localhost:5000/health || {
          echo "âŒ Health check baÅŸarÄ±sÄ±z!"
          exit 1
        }
        
        echo "âœ… Staging health check baÅŸarÄ±lÄ±!"
    
    - name: ğŸ§ª Smoke Tests
      run: |
        echo "ğŸ§ª Staging smoke tests Ã§alÄ±ÅŸÄ±yor..."
        
        # Basit smoke testleri
        python -c "
        import requests
        import json
        
        base_url = 'http://localhost:5000'
        
        # Test 1: Health check
        response = requests.get(f'{base_url}/health')
        assert response.status_code == 200
        print('âœ… Health check OK')
        
        # Test 2: Prediction endpoint
        test_data = {'value': 50}
        response = requests.post(f'{base_url}/predict', json=test_data)
        assert response.status_code == 200
        assert 'prediction' in response.json()
        print('âœ… Prediction endpoint OK')
        
        print('ğŸ‰ TÃ¼m smoke testler baÅŸarÄ±lÄ±!')
        "

  # 3ï¸âƒ£ Integration Tests
  integration-tests:
    name: ğŸ”— Integration Tests
    runs-on: ubuntu-latest
    needs: deploy-staging
    
    steps:
    - name: ğŸ“¥ Kodu Ä°ndir
      uses: actions/checkout@v4
    
    - name: ğŸ Python Kur
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: ğŸ“¦ Test BaÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± YÃ¼kle
      run: |
        pip install requests pytest
    
    - name: ğŸ”— End-to-End Tests
      run: |
        echo "ğŸ”— Integration testleri Ã§alÄ±ÅŸÄ±yor..."
        
        # KapsamlÄ± integration testleri
        python -c "
        import requests
        import time
        import json
        
        base_url = 'http://localhost:5000'
        
        def test_api_workflow():
            print('ğŸ§ª API workflow test ediliyor...')
            
            # Test senaryosu: Tam bir kullanÄ±cÄ± akÄ±ÅŸÄ±
            scenarios = [
                {'value': 10, 'expected_category': 'low'},
                {'value': 50, 'expected_category': 'medium'},
                {'value': 90, 'expected_category': 'high'}
            ]
            
            for i, scenario in enumerate(scenarios, 1):
                print(f'  Test {i}: Value {scenario[\"value\"]}')
                
                response = requests.post(f'{base_url}/predict', json=scenario)
                assert response.status_code == 200
                
                data = response.json()
                assert data['status'] == 'success'
                assert data['category'] == scenario['expected_category']
                print(f'    âœ… Kategori: {data[\"category\"]}')
            
            print('âœ… API workflow testleri baÅŸarÄ±lÄ±!')
        
        def test_performance():
            print('âš¡ Performance testleri...')
            
            times = []
            for i in range(10):
                start = time.time()
                response = requests.get(f'{base_url}/health')
                end = time.time()
                times.append(end - start)
                assert response.status_code == 200
            
            avg_time = sum(times) / len(times)
            print(f'    Ortalama response: {avg_time:.3f}s')
            assert avg_time < 0.1
            
            print('âœ… Performance testleri baÅŸarÄ±lÄ±!')
        
        test_api_workflow()
        test_performance()
        print('ğŸ‰ TÃ¼m integration testler baÅŸarÄ±lÄ±!')
        "

  # 4ï¸âƒ£ Production Approval
  production-approval:
    name: ğŸ” Production Onay
    runs-on: ubuntu-latest
    needs: [integration-tests, pre-deployment-checks]
    if: needs.pre-deployment-checks.outputs.deployment_env == 'production' || (github.ref == 'refs/heads/main' && needs.integration-tests.result == 'success')
    
    environment:
      name: production-approval
    
    steps:
    - name: ğŸ” Production OnayÄ± Bekleniyor
      run: |
        echo "ğŸ” Production deployment iÃ§in manuel onay bekleniyor..."
        echo "âœ… Staging testleri baÅŸarÄ±lÄ±"
        echo "âœ… Integration testleri baÅŸarÄ±lÄ±"
        echo "ğŸš€ Production'a deploy etmeye hazÄ±r!"

  # 5ï¸âƒ£ Production Deployment
  deploy-production:
    name: ğŸŒ Production Deploy
    runs-on: ubuntu-latest
    needs: [production-approval, build-and-push]
    if: success()
    
    environment:
      name: production
      url: https://api.example.com
    
    steps:
    - name: ğŸ“¥ Kodu Ä°ndir
      uses: actions/checkout@v4
    
    - name: ğŸŒ Production'a Deploy
      run: |
        echo "ğŸŒ Production deployment baÅŸlÄ±yor..."
        echo "ğŸ·ï¸ Image: ${{ needs.build-and-push.outputs.image_tag }}"
        
        # Blue-Green deployment simÃ¼lasyonu
        echo "ğŸ’™ Blue-Green deployment stratejisi kullanÄ±lÄ±yor..."
        
        # Yeni version'Ä± green slot'a deploy et
        echo "ğŸŸ¢ Green slot'a yeni version deploy ediliyor..."
        docker run -d --name production-green \
          -p 5001:5000 \
          -e ENVIRONMENT=production \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest || true
        
        sleep 15
        
        # Green slot health check
        echo "ğŸ” Green slot health check..."
        curl -f http://localhost:5001/health || {
          echo "âŒ Green slot baÅŸarÄ±sÄ±z!"
          exit 1
        }
        
        # Traffic switch (simÃ¼le edilmiÅŸ)
        echo "ğŸ”„ Traffic green slot'a yÃ¶nlendiriliyor..."
        echo "âœ… Production deployment tamamlandÄ±!"
    
    - name: ğŸ” Production Verification
      run: |
        echo "ğŸ” Production verification..."
        
        # Production endpoint'lerini test et
        python -c "
        import requests
        
        # Production health check
        response = requests.get('http://localhost:5001/health')
        assert response.status_code == 200
        
        data = response.json()
        assert data['status'] == 'healthy'
        
        print('âœ… Production verification baÅŸarÄ±lÄ±!')
        "

  # 6ï¸âƒ£ Post-Deployment
  post-deployment:
    name: ğŸ“Š Deployment SonrasÄ±
    runs-on: ubuntu-latest
    needs: deploy-production
    if: always()
    
    steps:
    - name: ğŸ“Š Deployment Raporu
      run: |
        echo "ğŸ“Š Deployment raporu oluÅŸturuluyor..."
        
        if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
          echo "âœ… Production deployment baÅŸarÄ±lÄ±!"
          echo "ğŸŒ API URL: https://api.example.com"
          echo "ğŸ“ˆ Monitoring: https://monitoring.example.com"
          
          # Slack bildirimi (simÃ¼le edilmiÅŸ)
          echo "ğŸ“¢ Slack'e baÅŸarÄ± bildirimi gÃ¶nderiliyor..."
          # curl -X POST $SLACK_WEBHOOK_URL -d '{"text":"ğŸš€ Production deployment baÅŸarÄ±lÄ±!"}'
          
        else
          echo "âŒ Production deployment baÅŸarÄ±sÄ±z!"
          echo "ğŸ”„ Rollback prosedÃ¼rÃ¼ baÅŸlatÄ±lmalÄ±"
          
          # Alert gÃ¶nder (simÃ¼le edilmiÅŸ)
          echo "ğŸš¨ Alert sistemi bilgilendiriliyor..."
          # curl -X POST $ALERT_WEBHOOK_URL -d '{"text":"âŒ Production deployment baÅŸarÄ±sÄ±z!"}'
        fi
    
    - name: ğŸ·ï¸ Release Tag OluÅŸtur
      if: needs.deploy-production.result == 'success'
      run: |
        echo "ğŸ·ï¸ Release tag oluÅŸturuluyor..."
        
        # Git tag oluÅŸtur
        TAG_NAME="v$(date +'%Y.%m.%d')-$(echo $GITHUB_SHA | cut -c1-7)"
        echo "Tag: $TAG_NAME"
        
        # GerÃ§ek uygulamada:
        # git tag $TAG_NAME
        # git push origin $TAG_NAME
    
    - name: ğŸ“‹ Deployment Ã–zeti
      run: |
        echo "ğŸ“‹ Deployment Ã–zeti"
        echo "=================="
        echo "ğŸ·ï¸ Version: ${{ needs.pre-deployment-checks.outputs.version_tag }}"
        echo "ğŸŒ Environment: ${{ needs.pre-deployment-checks.outputs.deployment_env }}"
        echo "ğŸ“… Tarih: $(date)"
        echo "ğŸ‘¤ Deployer: ${{ github.actor }}"
        echo "ğŸ”— Commit: ${{ github.sha }}"
        echo "ğŸ“Š Status: ${{ needs.deploy-production.result }}"